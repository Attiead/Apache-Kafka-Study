카프카 프로듀서
==

프로듀서는 카프카에 데이터를 저장하는 첫 단계.<br>

acks 옵션(acknowledge)
--
acks 옵션은 0, 1, all(또는 -1)의 값을 가짐.

이 옵션은 프로듀서가 전송한 데이터가 카프카 클러스터에 얼마나 신뢰성 높게 저장할지 지정하는 옵션.

1. acks = 0

- 프로듀서가 리더 파티션으로 데이터를 전송했을 때 리더 파티션으로 데이터가 저장되었는지 확인하지 않음.
- 프로듀서가 리더 파티션에 데이터가 저장되었는지 여부에 대한 응답 값을 받지 않음. => 데이터가 몇번째 오프셋에 저장되었는지 알 수 없음.
- retries옵션을 통해 전송 실패 시 재시도를 할 수 있는데, acks = 0 일 때는 전송하자마자 저장되었다 생각하고 바로 전송하기 때문에 실패 유무를 알 수 없음. 무의미한 옵션이 됨.
- 프로듀서와 브로커 사이의 네트워크 오류나 브로커의 이슈등으로 데이터가 유실되더라도 지속적으로 데이터를 보내기 때문에 전송속도가 빠름.(속도만 중요시 할때 필요함.)

2. acks = 1

- 프로듀서는 보낸 데이터가 리더 파티션에만 정상적으로 적재 되었는지 확임. => 적재 되지 않았다면 재시도 할 수 있음.
- 리더 파티션에 적재되었다 해도 데이터 유실될 수 있음 -> 복제 개수가 2 이상일때 팔로워 파티션에 아직 데이터 동기화가 이뤄지지 안은 사이에 리더의 브로커에 장애가 발생하면 일부 데이터 유실됨.
- 0 설정값에 비해 속도가 느림

3. acks = all or -1

- 리더와 팔로워 파티션에 모두 정상적으로 적재되었는지 확인함.
- 0과 1 옵션값에 비해 속도가 느림.
- 그러나 장애가 발생하더라도 안전성을 보장할 수 있음.
- all로 설정할 경우 min.insync.replicas 옵션값에 따라 데이터의 안정성이 달라짐. -> ISR에 포함된 파티션을 뜻하는 것이기 때문. <br>
    -> 프로듀서가 리더, 팔로워 파티션에 데이터가 적재되었느지 확인하기 위한 최소 ISR 그룹의 파티션 개수.<br>
  e.g) min.insync.replicas = 1 -> ISR 중 최소 1개 이상의 파티션에 데이터가 적재되었음을 확인 -> acks =1과 동일. ISR 중 최초 적재 파티션은 리더 이기 때문.<br>
  e.g) min.insync.replicas = 2 -> acks = all의 의미가 생김. ISR 중 2개 이상의 파티션에 데이터 정상 적재 확임. -> 적어도 한쌍의 리더, 파티션이 정상 적재임. (2개가 동시 중단은 드물다)

- min.insync.replicas를 설정할때는 복제 개수도 같이 고려해야함.<br> 
  해당 옵션값보다 작은 경우 프로듀서는 더는 데이터 전송할 수 없다. 복제 개수가 3이고 옵션값이 3일때 브로커 중 1대에 이슈가 발생하면 프로듀서가 해당 토픽에 전송할 수 없기 때문.<br> 
  따라서 브로커 개수와 동일한 숫자로 설정하면 안됨. 브로커 개수 미만으로 설정해서 운영해야함.

* 일반적으로 브로커를 3대 이상으로 묶어 클러스터 운영하고, 토픽의 복제개수는 3, min.insync.replicas = 2로 설정, acks=all 설정으로 추천함. 


멱등성(idempotence) 프로듀서
--
멱등성 : 여러 번 연산을 수행하더라도 동일한 결과를 나타내는 것을 뜻함. -> 여러번 전송되더라도 클러스터에 한 번만 저장됨을 의미.<br>

프로듀서의 기본 동작 방식은 적어도 한번 전달(at least once delivery)를 지원함. <br>
-> 프로듀서가 클러스터에 데이터를 전송하여 저장할 때 적어도 한 번 이상 데이터를 적재할 수 있고 데이터가 유실되지 않음을 뜻함. -> 두번 이상 적재할 가능성이 있어 중복 발생할 수 있음.

데이터의 중복 적재를 막기위해 enable.idempotence 옵션을 사용해서 '정확히 한번 전달'을 구현해냄.

기본값은 false, 위 기능을 사용하려면 true로 멱등성 프로듀서로 동작하게 함.

* 구동방식
멱등성 프로듀서는 데이터를 브로커로 전달할 때 프로듀서 PID(Producer unique ID)와 시퀀스 넘버를 함께 전달함.<br>
두 값을 확인하여 단 한번 적재를 필터링함.

- 멱등성 프로듀서는 동일한 세션(PID 생명주기)에서만 정확히 한번 전달을 보장함. -> 애플리케이션 재시작시 PID 달라짐. 
- enable.idempotence = true 설정 시 retries = Integer.MAX_VALUE, acks = all이 자동 설정됨. 
- 시퀀스 넘버가 일정 하지 않은 경우 OutOfOrderSequenceException이 발생함.


트랜잭션 프로듀서
--
다수의 파티션에 데이터를 저장할 경우 모든 데이터에 대해 동일한 원자성(atomic)을 만족시키기 위해 사용됨.<br>

다수의 데이터를 동일 트랜잭션으로 묶음으로써 전체 데이터를 처리하거나 처리하지 않도록 하는 것을 의미.

컨슈머는 기본적으로 프로듀서가 보내는 데이터가 피티션에 쌓이는 대로 가져가서 처리함.<br>
but, 트랜잭션으로 묶인 데이터를 브로커에서 가져갈 때는 다르게 동작. 

enable.idempotence=true, transactional.id="임의의값", 컨슈머의 isolation.level=read_committed로 설정.<br>
-> 프로듀서와 컨슈머는 트랜잭션으로 처리 완료된 데이터만 쓰고 읽게 됨.

트랜잭션은 파티션의 레코드로 구분함. 

- 사용자가 보낸 데이터를 레코드로 파티션에 저장 + 트랜잭션의 시작과 끝을 표현하기 위해 레코드를 한개 더 보냄.
- 트랜잭션 컨슈머는 파티션의 트랜잭션 레코드를 보고 트랜잭션 완료(commit) 확인 후 데이터를 가져감. 
- 트랜잭션 레코드는 트랜잭션이 끝난 상태를 표시하는 정보'만' 가지고 있음(데이터 X)
- 오프셋은 하나 차지함. 

* 구동방식
커밋이 완료된 데이터가 파티션에 있을 때 트랜잭션 컨슈머가 데이터를 가져감. (트랜잭션 레코드가 존재하지 않으면 가져가지 않음)
