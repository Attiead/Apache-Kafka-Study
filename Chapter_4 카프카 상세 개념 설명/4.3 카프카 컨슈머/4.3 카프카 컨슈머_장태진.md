카프카 컨슈머
==
컨슈머 : 적재된 데이터를 클러스터로 부터 가져가고 처리한다.

멀티 스레드 컨슈머
--

파티션과 컨슈머 개수를 늘려서 처리량을 늘릴수 있음. -> 병렬처리하기 위해 개수를 동일하게 맞춤.

n개의 파티션 = 동일 컨슈머 그룹의 컨슈머 스레드는 최대 n개 => n개의 스레드를 가진 1개의 프로세스 운영 or 1개의 스레드를 가진 프로세스를 n개 운영

- 멀티스레드를 지원 X -> 프로세스를 여러개 실행(1개의 스레드를 가진 프로세스를 n개)
- 멀티스레드를 지원 O -> 1개의 프로세스에 여러 스레드(n개의 스레드를 가진 1개의 프로세스)

자바는 멀티 스레드로 동작하는 멀티 컨슈머 스레드를 개발 및 적용!

멀티 스레드로 운영할 경우
- 하나의 컨슈머 스레드에서 예외( ex)OOME )가 발생하면 포로세스 자체가 종료될 수도 or 다른 컨슈머 스레드에까지 영향을 미칠 수도 있다.
- 각 스레드 간 영향이 미치지 않도록 스레드 세이프 로직, 변수를 적용

<h3>컨슈머 멀티 워커 스레드 전략
-

컨슈머 스레드는 1개만 실행하고 데이터 처리를 담당하는 워커 스레드(worker thread)를 여러 개 실행하는 방식

브로커로부터 전달받은 레코드를 
1. 병렬 처리 - 1개의 컨슈머 스레드로 받은 데이터들을 빠르게 처리가능
2. for 반복구문 처리 - 이전 레코드의 처리가 끝날 때까지 다음 레코드가 기다려야함. 

자바 라이브러리인 ExecutorService를 이용해 멀티 스레드를 생성하여 레코드를 병렬처리하는 스레드를 효율적으로 생성하고 관리할 수 있다.

Executors를 사용하여 스레드 개수를 제어하는 thread pool을 생성.<br>
작업 이후 스레드 종료되야 한다면 CachedThreadPool을 사용하여 스레드를 시작함. 

1. Runnable 인터페이스를 구현받은 ConsumerWorker로 생성함.<br>
2. 스레드 실행을 위해 ExecutorService.execute(worker)를 사용.
3. 레코드를 출력하고 출력이 완료되면 스레드를 종료하도록 new CachedThreadPool 사용. <br>
   -> newCachedThreadPool은 필요한 만큼 스레드 풀을 늘려서 스레드를 실행하는 방식. 짧은 시간의 생명주기를 가진 스레드에서 유용함.
4. poll()메서드를 통해 리턴받은 레코드들을 처리하는 스레드를 레코드마다 개별 실행함. 개별 로그 출력됨.

* 주의사항
1) 스레드를 사용함으로써 데이터 처리가 끝나지 않았음에도 커밋을 하기때문에 리밸런싱, 컨슈머 장애 시에 데이터 유실 발생 가능.<br>
   각 레코드 데이터 처리가 끝났음을 리턴받지 않고 다음 poll 메서드를 호출 시 auto commit일 경우는 커밋이 되버림.
2) 레코드 처리의 역전현상. <br>
   for 구분으로 반복되서 스레드 생성되지만. 스레드의 처리시간이 다를 수 있기에 이전 레코드보다 다음 레코드가 먼저 처리되면서 레코드의 순서가 바뀔수 있음.

> 레코드 처리 중 중복 발생, 데이터 역전현상이 발생해도 속도만 빠르면 될 때 적합. 
> e.g)서버 리소스 모니터링 파이프라인, IoT 서비스 센서 데이터 수집 파이프 라인.


<h3>컨슈머 멀티 스레드 전략
--

컨슈머 인스턴스에서 poll()메서드를 호출하는 스레드를 여러 개 띄워서 사용하는 방식

파티션 개수만큼 컨슈머 스레드를 늘려 병렬처리하는 애플리케이션 운영방식이 가능.<br>
컨슈머 스레드가 파티션 개수보다 많아지면 할당할 파티션 개수가 더는 없으므로 파티션에 할당되지 못한 컨슈머 스레드는 데이터 처리를 하지않게 된다.

1개의 애플리케이션에 n개의 컨슈머 스레드를 띄우는 방식

1. Runnable 인터페이스를 구현받은 ConsumerWorker로 생성함.<br>
2. 스레드별로 Kafka Consumeer 인스턴스를 별개로 만듬. (스레드 세이프 하지 않음)
3. Consumer 생성시 컨슈머 옵션, 토픽 이름, 스레드 번호를 생성자로 받아 인스턴스 생성. 
4. 생성시 받은 토픽이름을 consumer.subscribe()로 구독. 
5. consumer.poll() 메서드로 리턴 레코드 처리.
6. 레코드를 출력하고 출력이 완료되면 스레드를 종료하도록 new CachedThreadPool 사용. <br>
7. 컨슈머 개수 만큼 worker를 만들고 execute(worker)를 통해 실행.


컨슈머 랙
--

컨슈머 LAG : 토픽의 최신 오프셋과 컨슈머 오프셋 간의 차이.

프로듀서는 계속해서 새로운 데이터를 파티션에 저장하고 컨슈머는 자신이 처리할 수 있는 만큼 데이터를 가져감.

프로듀서가 보내는 데이터양이 컨슈머의 데이터 처리량보다 크다면 컨슈머 랙은 늘어난다.<br>
반대로 보내는 데이터양이 처리량보다 적으면 컨슈머 랙은 줄어들고 최솟값은 0.

> 컨슈머 랙을 모니터링 하는 것은 카프카를 통한 데이터 파이프라인을 운영하는 데에 핵심적인 역할을 함.

- 컨슈머의 장애 확인
- 파티션 개수를 정하는데 참고.

컨슈머 랙이 발생한다면 지연을 줄이기 위해 일시적으로 파티션 개수와 컨슈머 개수를 늘려서 병렬처리량을 늘리는 방법을 사용할 수 있음.

2개의 파티션과 2개의 컨슈머가 할당되었을 경우 프로듀서가 보내는 데이터 양은 동일한데 1번 파티션의 컨슈머 랙이 늘어남<br>
-> 1번 파티션에 할당된 컨슈머에 이슈가 발생했음을 유추.

1. 카프카 명령어를 사용한 컨슈머 랙 조회

kafka-consumer-groups.sh 명령어를 사용하여 특정 컨슈머 그룹의 상태를 확인 가능.<br>

지속적인 모니터링하기엔 부족. 테스트용 카프카에서 사용함.

```shell
$ bin/kafka-consumer-groups.sh --bootstrap-server my-kafak:9092 --group my-group --describe
```


2. 컨슈머 metrics() 메서드를 사용.

모니터링 지표
1) records-lag-max
2) records-lag
3) records-lag-avg

문제점.
- 컨슈머 정상 동작시에만 사용 가능. -> metrics()가 컨슈머 상태가 정상일때만 호출됨.
- 모든 컨슈머 애플리테이션이 랙 모니터링 코드를 중복해서 작성해야함. 
- 모니터링 코드를 추가할 수 없는 카프카 서드 파티 애플리케이션에서는 불가능.

3. 외부 모니터링 툴을 사용하여 컨슈머 랙 조회.<br>
가장 최선!

Datadog, Confluent Control Center와 같은 종합 모니터링 툴 사용.

오픈소스로 Burrow도 있음. REST API를 통해 컨슈머 그룹별로 컨슈머 랙을 확인 가능. 


<h4>카프카 버로우
--
오픈소스 컨슈머 랙 체크 툴.

버로우는 다수의 카프카 클러스터를 동시에 연결하여 랙을 확인함. 

HTTP, SMTP를 이용한 알람기능 모듈이 제공되긴 하지만 데이터 적재 기능이 없음.<br>
-> 현시점 외에 history성 데이터를 위해 별도의 저장소와 대시보드가 필요함.<br>
-> 별도 저장소(인플럭스디비, 엘라스틱서치 등)에 저장하고 대시보드(그라파나, 키나나 등)으로 조회, 알림 설정할 것.

컨슈머 랙의 상태를 표현하는 것을 랙 평가라고 부름.

파티션의 상태를 OK, STAILED, STOPPED / 컨슈머의 상태를 OK, WARNING, ERROR로 표현한다.

임계치 그래프 방식이 아닌. 최신 오프셋과 컨슈머 오프셋을 비교하여 시간에 따른 컨슈머 랙의 상태에 따른 코드를 전달하여 모니터링 한다.


[ 컨슈머 랙 모니터링 아키텍처 ]

- 버로우(클러스터에서 컨슈머 랙 조회) 
- 텔레그래프(버로우를 조회하여 엘라스틱서치에 전달), 
- 엘라스틱서치(랙 정보를 담는 저장소)
- 그라파나(엘라스틱서치 정보 시각화 및 조건에 따른 알림 가능한 대시보드 툴)

엘라스틱 서치에 파티션, 컨슈머의 상태가 저장되어 있으므로 상태를 기반으로 알람을 받으면 컨슈머의 장애에 즉각적으로 대응할 수 있다!


컨슈머 배포 프로세스
--

<h4>중단 배포
--
컨슈머 애플리케이션을 완전히 종료한 이후에 개선 코드로 배포하는 방식.

물리 장비 운영의 경우에서 사용됨.

기존 컨슈머 애플리케이션이 종료되면 더는 토픽의 데이터를 가져갈 수 없기 때문에 컨슈머 랙이 늘어남.<br>
-> 지연 발생

파이프라인을 운영하는 서비스가 계속 중단되있는 상황에서 신뢰성 있는 배포 시스템을 가진 기업에 추천.

장점 : 배포 시점의 오프셋을 로깅한다면 신규 배포 ver에 이슈가 발생해서 롤백할 경우 해당 시점으로 기준잡을 수 있음.

<h4>무중단 배포
--
인스턴스의 발급과 반환이 다소 유연한 가상 서버를 사용하는 경우에 유용함.

블루/그린, 롤링, 카나리 배포가 있다.

1. 블루/그린<br>
이전 ver와 신규 ver를 동시에 띄워놓고 트래픽을 전환하는 방법.<br>
파티션 개수와 컨슈머 개수가 동일한 경우에 사용 가능.<br>
신규 ver를 띄워놓고 유휴 상태로 둔 다음. 기존 ver를 종료하면 리밸런싱이 발생하면서 기존 파티션은 모두 신규 컨슈머와 연동된다. <br>
2개를 띄워놓고 기다렸다가 교체하는 방식

   
2. 롤링<br>
블루/그린의 인스턴스 할당과 반환으로 인한 리소스 낭비를 줄일 수 있음.<br>
파티션개수가 인스턴스 개수와 같거나 그보다 많아야함. <br>
파티션 2개로 운영하는 토픽이 있다면 1개의 인스턴스를 신규버젼으로 실행하고 모니터링한 후<br>
1개의 인스턴스로 신규 버전으로 배포하여 롤링 업그레이드를 진행할 수 있다. <br>
파티션 개수가 많지 않은 경우에 효과적인 방법. 1개씩 변경


3. 카나리<br>
작은 위험을 통해 큰 위험을 예방하는 방법.<br>
데이터 중 일부분을 신규 ver에 먼저 배포해봐서 탐지 .<br>
100개 파티션으로 운영되는 토픽에서 1개의 파티션에 컨슈머를 따로 배정하여 신규 ver로 테스트 후 <br>
나머지에 대해 롤링 또는 블루/그린 배포를 수행하는 것.


