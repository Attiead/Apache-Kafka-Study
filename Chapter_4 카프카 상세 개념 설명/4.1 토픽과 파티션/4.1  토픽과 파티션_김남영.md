# 토픽과 파티션
- 토픽이 사라지면 카프카 파이프 라인은 동작하지 않음.

<bR>

## 적정 파티션 개수
- 토픽의 파티션의 개수는 카프카 성능과 밀접한 관계가 있다.
- 파티션의 개수를 적절하게 설정하고 운영하자.

### 파티션 개수를 정할 때 고려할 점
- 데이터 처리량
- 메시지 키 사용 여부
- 브로커와 컨슈머의 영향도
    - 파일 시스템을 사용하는 카프카는, 파티션의 수 만큼 파일에 접근한다.
    - 운영체제 특성 상 프로세스 당 접근 가능한 파일 개수가 정해져 있다.
    - 브로커가 접근하는 파일 개수를 안정적으로 유지하고 싶을 경우는, 카프카 브로커의 수를 늘리면 된다.

### 데이터 처리 속도를 올리자
1. 컨슈머의 처리량 늘리기
    - 컨슈머가 실행되는 서버를 스케일업
    - GC 튜닝
    - 컨슈머는 (S3, 하둡, 오라클 등등) 의 시스템과 연동되므로, 일정 수준 처리량을 높이는데, 한계가 있다.
2. 컨슈머 추가로 병렬 처리량 늘리기 => 제일 베스트
    - 파티션의 개수를 늘린만큼 컨슈머를 추가
    - 프로듀서의 발행 데이터가 초당 1000 Records
    - 컨슈머가 처리 가능한 데이터 초당 100 Records 
    - 최소 필요한 파티션의 개수 10개
- 파티션의 개수만 늘리는 것은 마냥 좋진 않다.
- 파티션의 개수를 늘리므로서 컨슈머와 브로커의 부담이 커진다.

<br>

## 토픽 정리 정책

<br>

### 토픽 삭제 정책
- 토픽의 데이터 삭제는 기본적으로 세그먼트 단위로 진행
- 세그먼트란?
    - 토픽의 데이터를 저장하는 명시적인 파일 시스템 단위
    - 파티션마다 별개로 생성
    - 세그먼트의 파일 이름은 오프셋 중 가장 작은 값
- 세그먼트는 여러 조각으로 나뉨 **segment.bytes** 옵션으로 1개의 세그먼트 크기 조정
- 해당 옵션 크기보다 커질 경우, 기존 적재중인 세그먼트 파일을 닫고, 새로운 세그먼트를 열어 저장

- 삭제 정책이 실행되는 시점은 시간 또는 용량이 기준
- **retension.ms** 옵션으로 토픽의 데이터를 유지하는 기간 설정
- 카프카는 일정 주기마다 세그먼트 파일의 마지막 수정 시간과 retension 을 비교
- 세그먼트 파일의 마지막 수정시간이 이를 넘길 경우 세그먼트 삭제
- bytes 는 토픽의 최대 데이터 크기 제어
- 넘길 경우 세그먼트 파일들 삭제 => 삭제 데이터 복구 불가

<br>

### 토픽 압축 정책
- 메시지 키 별로 해당 메시지 키의 레코드 중 가장 오래된 데이터 삭제
- 압축 정책이란 액티브 세그먼트 제외 나머지 세그먼트들의 데이터 처리
- 압축 시점은 **min.cleanable.clity.ratio** 옵션 설정 가능
- 이 옵션 값은 액티브 세그먼트 제외 세그먼트에 남은 데이터의 tail 영역 레코드 개수와 head 영역 레코드 개수의 비율

<img src="https://user-images.githubusercontent.com/89288109/230725356-897cfd41-fd75-448b-9a4f-876998458f4b.png">

<br>

- tail 영역의 레코드 = clean log
- 압축이 완료되었으므로, 중복된 메시지 키가 없음
- head 영역 레코드 = dirty log
- 압축 되기 전 레코드들, 중복된 메시지 키를 가진 레코드가 존재
- 토픽의 압축은 ratio 옵션 값을 따르는데, 0.5로 설정할 경우 dirty log 의 비율이 이를 넘길 시 압축을 수행
- 옵션 값이 낮을 수록 압축은 자주 발생 => 브로커에 부담

<br>

## ISR (In-Sync-Replicas)
- 리더 파티션과 팔로워 파티션이 모두 싱크가 된 상태
- 팔로워 파티션이 리더 파티션으로부터 데이터를 복제하는 데 시간이 걸리기 때문
    - 리더 파티션에 새로운 레코드 추가 및 오프셋 증가
    - 팔로워 파티션이 위치한 브로커는 리더 파티션의 데이터 복제
    - 리더 파티션에 데이터가 적재된 후 팔로워 파티션이 복제하는 시간 차이가 생김
    - 리더 파티션과 팔로워 파티션 간 오프셋 차이 발생
- 이런 차이를 모니터링 해야함
- 리더 파티션은 **replica.time.max.ms** 의 값 만큼 주기를 가지고, 팔로워 파티션이 데이터를 복제하는지 확인
- 팔로워 파티션이 옵션 값보다 더 긴 시간동안 데이터를 가져가지 않을 경우, 팔로워 파티션에 문제가 생김으로 판단
- ISR 그룹에서 제거

