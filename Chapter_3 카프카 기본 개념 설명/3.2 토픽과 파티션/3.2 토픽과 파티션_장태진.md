토픽
==

데이터의 구분 단위.
- 1개 이상의 파티션을 소유함.
- 파티션에는 프로듀서가 보낸 데이터가 들어가 저장됨 -> 레코드

컨슈머의 처리량이 한정된 상황에서 많은 레코드를 병렬로 처리하는 가장 좋은 방법은<br>
컨슈머의 개수를 늘려 스케일 아웃하는 것이다. 

파티션은 큐와 비슷한 구조. 단, pop했을 때 레코드 삭제가 이뤄지지 않음.<br>
토픽의 레코드는 다양한 목적을 가진 여러 컨슈머 그룹들이 토픽의 데이터를 여러번 가져갈 수 있음.

제약조건
--
- 빈 문자열 X
- .  or .. 으로 생성 X
- 249자 미만
- 대소문자 0-9 . __ - 조합으로 생성
- 내부 로직 관리 목적의 토픽(__consumer_offsets, __transaction_state)로는 사용불가
- 토픽 이름에 .와 _ 가 동시에 들어가면 안됨. 사용은 되지만 이슈가 발생할 수 있기에 warning 메시지 발생
- to.pic 이 있다면 to_pic으로는 생성 불가

작명방법
--
- 토픽은 데이터의 얼굴
- 어떤 데이터타입으로 사용되는지 유추할 수 있어야함.
- 토픽의 오너쉽을 가진 팀의 이름을 추가하는 것도 고려.
- JIRA의 티켓 번호를 사용하여 히스토리 파악에도 좋음. 
- 클러스터가 2대 이상이라면 클러스터 이름을 넣어 구분도 가능.
- 카멜케이스보단 케밥 or 스네이크를 추천함. 

e.g) 
- <환경>.<팀-명>.<애플리케이션-명>.<메시지-타입> : prd.marketing-team.sms-platform.json
- <프로젝트-명>.<서비스-명>.<환경>.<이벤트-명> : commerce.payment.prd.notification
- <환경>.<서비스-명>.<JIRA-no>.<메시지-타입> : dev.email-sender.jira-1234.email-vo-custom
- <카프카-클러스터-명>.<환경>.<서비스-명>.<메시지-타입> : aws-kafka.live.marketing-platform.json

> 규칙을 정하는 것이 가장 중요함. 
> 토픽 이름 변경을 지원하지 않기에 삭제후 다시 생성해야하기 때문. 


