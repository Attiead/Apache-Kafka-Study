##### 컨슈머 소게
* 카프카 브로커에 적재된 데이터를 사용하기 위해 브로커로부터 데이터를 가져와서 필요한 처리를 한다.

##### 컨슈머를 운영하는 방법
1. 한 개 이상의 컨슈머로 이루어진 컨슈머 그룹을 운영
   * 컨슈머 개수
     * `컨슈머의 개수 <= 파티션의 개수이어야` 함... `컨슈머의 개수 > 파티션의 개수` 이면 스레드 낭비
   *  컨슈머 그룹은 다른 컨슈머 그룹과 격리되는 특징을 가짐
     * 타깃이 2개 일때 컨슈머 그룹이 2개이면 각각의 타깃에 데이터를 적재하기에, 타깃 중 하나에 장애가 발생해도 다른 하나에는 영향을 미치지 않는다.
2. 토픽의 특정 파티션만 구독하는 컨슈머를 운영

##### 컨슈머 장애
* 리밸런싱
  * 컨슈머 그룹 안의 일부 컨슈머에 장애가 발생하면, 장애가 발생한 컨슈머에 할당된 파티션은 장애가 발생하지 않은 컨슈머에 소유권이 넘어감.
  * 발생하는 경우
    * 컨슈머가 추가되는 상황
    * 컨슈머가 제외되는 상황
  * 누가 ?
    * 그룹 조정자 (group coordinator) : 컨슈머가 추가, 삭제될 때를 감지.
    * 카프카 브로커 중 하나
  * 오프셋
    * 컨슈머는 데이터를 어디까지 가져갔는지 커밋을 통해 기록.
    * 특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째 가져갔는지, 카프카 브로커 내부에서 사용되는 내부 토픽(_consumer_offsets)에 기록됨
    * 오프셋 커밋이 기록되지 않으면 데이터 처리의 중복이 발생할 수 있다. 
    * 오프셋 커밋을 정상적으로 처리했는지 검증해야함
      * 기본 옵션 - poll() 수행 시 일정간격 마다 자동으로 커밋되는 비명시 '오프셋 커밋'
        * auto.commit.interval.ms에 설정, 별도의 코드 필요 없음
        * 단점은 취약한 구조.. poll() 호출 이후 리밸런싱 또는 컨슈머 강제종료 발생 시 컨슈머가 처리하는 데이터가 중복 또는 유실될 수 있음
      * 커스텀 옵션 - poll() 메서드 호출 후 반환받는 데이터의 처리가 완료되고, commitAsync() 메서드를 호출하면 됨.

##### 오프셋 커밋
1. 동기 오프셋 커밋
   * poll() 메서드가 호출된 이후 commitSync() 메서드를 호출하여 오프셋 커밋을 명시적으로 수행 가능
   * commitSync()
     * 호출 시점 : 모든 레코드의 처리가 끝난 이후
       * commitSync()는 poll() 메서드로 받은 가장 마지막 레코드의 오프셋을 기준으로 커밋
     * 파라미터
       * 없으면 가장 반환된 가장 마지막 레코드의 오프셋을 기준으로 커밋
       * custom을 원할 경우 Map<TopicPartition, OffsetAndMetadata> 인스턴스를 파라미터에 넣으면 됨
2. 비동기 오프셋 커밋
   * 커밋 응답을 기다리면 데이터 처리가 일시적으로 중단되기 때문에 더 많은 데이터 처리가 필요할 때 비동기 오프셋 커밋을 사용.
   * 동기 오프셋 커밋처럼 poll() 메서드로 리턴된 가장 마지막 레코드를 기준으로 오프셋을 커밋하나, 응답을 기다리지 않음
   * ```java
     consumer.sommitAsync(new OffsetCommitCallback()) {
        public void onComplete(Map<TopicPartion, OffsetAndMetadata> offsets, Exception e) {
            if (e != null)
                System.out.println("Commit failed");
            else
                System.out.println("Commit succeedded");
            if (e != null)
                logger.error("Commit failed for offsets {}", offsets, e);
        }
     });
     ```
##### 컨슈머 주요 옵션
* 필수 옵션
  * 프로듀서와 일치
* 선책 옵션
  * group.id : 컨슈머 그룹 아이디를 지정, subscribe() 메서드로 토픽을 구독하여 사용할 때는 이 옵션을 필수로 넣어야 함
  * auto.offset.reset : 저장된 컨슈머 오프셋이 없는 경우 어느 오프셋부터 읽을지 선택하는 옵션, latest(기본값), earliest, none
  * enable.auto.commit : 자동 커밋(true) or 수동 커밋
  * auto.commit.interval.ms : 기본값은 5초, 위 설정이 자동 커밋일 경우 오프셋 커밋 간격을 지정.
  * max.poll.records : poll() 메서드를 통해 반환되는 레코드 개수를 지정, 기본값 500
  * session.timeout.ms : 컨슈머가 브로커와 연결이 끊기는 최대 시간. 이 시간 내 하트비트를 전송하지 않으면 브로커는 컨슈머에 이슈가 발생했다고 가정하고 리밴런싱 시작. 보통 하트비트 시간 간격의 3배.
  * heartbeat.interval.ms : 하트비트를 전송하는 시간 간격
  * max.poll.interval.ms : poll() 메서드를 호출하는 간격의 최대시간, 비정상이라고 판단될 경우 리밸런싱
  * isolation.level : 트랜잭션 프로듀서가 레코드를 트랜잭션 단위로 보낼 경우 사용.
    * read_committed : 커밋이 완료된 레코드만 읽음
    * reae_uncommitted : 커밋 여부와 상관 없이 파티션에 있는 모든 레코드를 읽음(기본값)

##### 컨슈머 정리
1. 리밸런스 리스너를 가진 컨슈머

2. 파티션 할당 컨슈머

3. 컨슈머에 할당된 파티션 확인 방법

4. 컨슈머의 안전한 종료
